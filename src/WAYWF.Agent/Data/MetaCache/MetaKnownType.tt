// Copyright (c) Brian Reichle.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
<#@template language="C#" #>
<#@output extension=".g.cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ include file="..\..\Utils\TypeReferences.t4" #>
using System;
using System.Collections.Generic;
using WAYWF.Agent.CorDebugApi;

<#
var unmarshalableTypes = new[] { typeof(void), typeof(object), typeof(TypedReference) };
#>
namespace WAYWF.Agent.MetaCache
{
	internal unsafe partial class MetaKnownType
	{
		public static readonly MetaKnownType String = new MetaStringType();
<#
foreach (var type in knownValueTypes)
{
	string shortName;

	if (!shortNameLookup.TryGetValue(type, out shortName))
	{
		shortName = type.Name;
	}

#>
		public static readonly MetaKnownType <#=type.Name#> = new MetaValueType<<#=shortName#>>();
<#
}

foreach (var type in unmarshalableTypes)
{
#>
		public static readonly MetaKnownType <#=type.Name#> = new MetaKnownType("<#=type.FullName#>", 0);
<#
}
#>

		public static MetaKnownType FromElementType(CorElementType type)
		{
			switch (type)
			{
<#

foreach (var pair in elementTypes.OrderBy(p => p.Value))
{
#>
				case CorElementType.<#=pair.Value#>: return <#=pair.Key.Name#>;
<#
}

#>
				default: throw new ResolutionException(type);
			}
		}

		static readonly Dictionary<string, MetaKnownType> _lookup = new Dictionary<string, MetaKnownType>()
		{
<#
foreach (var type in knownValueTypes.Concat(unmarshalableTypes).Concat(new[] { typeof(string) }))
{
#>
			{ <#=type.Name#>.Name, <#=type.Name#> },
<#
}
#>
		};
	}
}
